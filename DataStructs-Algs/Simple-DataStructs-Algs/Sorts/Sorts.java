package student_classes;
import static student_collections.SList.*;
import student_collections.SList;

/**
 * Common location to contain the quicksort and mergesort routines. Note, you will also
 * create public methods that are required to support (implement) these sorts, such as
 * "append," "merge," and maybe others.
 * 
 * <h1>Important Considerations here!</h1>
 * Please read through these carefully:
 * <ul>
 * <li>No iterative constructions should be used here.</li>
 * <li>No exception handling will be permitted.</li>
 * <li>Use the special "NULL" from the SList package in place of Java's 
 * <code>null</code>, or, better, return the original argument if it 
 * has been reduced to null.</li>
 * <li><b>DO NOT</B> import anything from java.util.* in this file.</li>
 * <li>Do not mess with the imports at the top of this file, or in the
 * StudentTests file.</li>
 * </ul>
 * 
 * @author UMD CS Department.
 *
 */
public class Sorts {
	/**
	 *Takes two lists and creates a new list containing the elements 
	 *of the original lists in their original order.
	 * @param list1
	 * @param list2
	 * @return a new list containing the elements of the original lists 
	 * in their original order
	 */
	public static <T> SList<T> append( SList<T> list1, SList<T> list2 ) {
		if (isEmpty(list1)) {
			return list2;
		} else {
			return cons(first(list1), append(rest(list1), list2));
		}
	}
	/**
	 * Returns a new list that contains the first pos elements of list. 
	 * If the list has fewer than pos elements, an IllegalStateException is thrown.
	 * @param list
	 * @param index
	 * @exception IllegalStateException
	 * @return a new list that contains the first pos elements of list.
	 */
	public static< T > SList<T> take( SList<T> list, int pos ) {
		if (pos > length(list) - 1) {
			throw new IllegalStateException();
		} else if (pos == 0) {
			return createList();
		} else {
			return cons(first(list), take(rest(list), pos - 1));
		}
	}
	
	/**
	 * Returns a new list that contains the remaining pos elements of 
	 * list If the list has fewer elements than pos elements, an 
	 * IllegalStateException is thrown.
	 * Note: <code>drop( someList, 0 )</code> returns the original list.
	 * @param list
	 * @param pos
	 * @exception IllegalStateException
	 * @return a new list that contains the remaining pos elements of list
	 */
	public static < T > SList< T > drop( SList< T > list, int pos ) {
		if (pos > length(list) - 1) {
			throw new IllegalStateException();
		} else if (pos == 0) {
			return list;
		} else {
			return drop(rest(list), pos - 1);
		}
	}
	/**
	 * Performs the classic "merge sort" by treating the empty list 
	 * or the singleton list as already sorted and then recursively
     * merging the results of reducing each sublist generated by a pivot.
	 * @param list
	 * @return a new list that contains the elements in <code>list</code> 
	 * and has them sorted
	 */
	public static <T extends Comparable< T >> SList<T> mergeSort(
			SList<T> list ) {
		if(isEmpty(list) || length(list) == 1) {
			return list;
		} else {
			int mid = length(list)/2;
			return merge(mergeSort(take(list, mid)), mergeSort(drop(list, mid)));
		}
	}
	
	private static <T extends Comparable< T >> SList<T> merge(
			SList<T> list1, SList<T> list2) {
		if (isEmpty(list1)) {
			return list2;
		} else if (isEmpty(list2)) {
			return list1;
		} else {
			if (first(list1).compareTo(first(list2)) < 0) {
				return cons(first(list1), merge(rest(list1), list2));
			} else {
				return cons(first(list2), merge(list1, rest(list2)));
			}
		}
	}
	/**
	 * Performs the classic quicksort â€”claimed to be the fastest in its class.
	 * @param list
	 * @return  a new list that contains the elements in <code>list</code> 
	 * and has them sorted
	 */
	public static <T extends Comparable<T>> SList<T> qSort(
			SList<T> list ) {
		if (isEmpty(list)) {
			return list;
		} else {
			T pivot = first(list);
			SList<T> less = partition(list, "<", pivot);
			SList<T> equal = partition(list, "=", pivot);
			SList<T> greater = partition(list, ">", pivot);
			return append(append(qSort(less), equal), qSort(greater));
		}
	}
	
	private static <T extends Comparable<T>> SList<T> partition(
			SList<T> list, String partition, T pivot) {
		if (isEmpty(list)) {
			return list;
		} else if (partition.equals("<")) {
			if (first(list).compareTo(pivot) < 0) {
				return cons(first(list), partition(rest(list), partition, pivot));
			} else {
				return partition(rest(list), partition, pivot);
			}
		} else if (partition.equals("=")) {
			if (first(list).compareTo(pivot) == 0) {
				return cons(first(list), partition(rest(list), partition, pivot));
			} else {
				return partition(rest(list), partition, pivot);
			}
		} else {
			if (first(list).compareTo(pivot) > 0) {
				return cons(first(list), partition(rest(list), partition, pivot));
			} else {
				return partition(rest(list), partition, pivot);
			}
		}
	}
}
